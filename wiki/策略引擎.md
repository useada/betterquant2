# 策略引擎接口

## 下单
c++
```c++
   std::tuple<int, OrderId> order(const StgInstInfoSPtr& stgInstInfo,
                                  AcctId acctId, MarketCode marketCode,
                                  const std::string& symbolCode, Side side,
                                  PosDirection posDirection, Decimal orderPrice,
                                  Decimal orderSize,
                                  OrderStg orderStg = OrderStg::RejectCloseTDay,
                                  AlgoId algoId = 0,
                                  const SimedTDInfoSPtr& simedTDInfo = nullptr);
```
python
```python
    def order(stg_inst_info, acct_id, market_code, symbol_code, side, 
              pos_direction, order_price, order_size, order_stg, algo_id, simed_td_info)   
```

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | StgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| acctId | uint16 | 系统账号 |
| marketCode | MarketCode | 市场 |
| symbolCode | String | 代码 |
| side | Side | 买卖 |
| posDirection | PosDirection | 开平 |
| orderPrice | Double | 下单价格 |
| orderSize | Double | 下单数量 |
| orderStg | OrderStg | 下单策略，比如是否允许平今仓 |
| algoId | uint32 | 算法单id |
| simedTDInfo | SimedTDInfo | 模拟成交信息 |

对于郑商所、大商所和中金所，可以通过OrderStg指定是否允许平今仓，不允许平今的情况下，如果发现当前平仓单是平今单，那么系统马上会拒单。如果是回测，需要生成模拟单，那么可以填写simedTDInfo，指定模拟的订单最终状态，模拟单用c/c++中的变长结构体实现，所以实盘中不会有额外的空间占用。  
  
</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| orderId | uint64 | 发送的订单的id |  
  
</br>
</br>
</br>

---

&emsp;&emsp;
<br/>


## 通过OrderInfo下单
c++
```c++
   std::tuple<int, OrderId> order(OrderInfoSPtr& orderInfo);
```
python
```python
    def order(orddr_info)   
```

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| orderInfo| OrderInfo | 订单信息 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| orderId | uint64 | 发送的订单的id |  

OrderInfo参考[订单信息](策略引擎#订单信息)  
  

&emsp;&emsp;
<br/>


---

## 撤单
c++
```c++
    int cancelOrder(OrderId orderId);
```
python
```python
    def cancel_order(order_id)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| orderId | uint64 | 内部订单id |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |


&emsp;&emsp;
<br/>

---

## 撤销策略所有挂单
c++
```c++
    std::vector<OrderId> cancelAllOrderOfStg();
```
python
```python
    def cancel_all_order_of_stg()
```

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| OrderIdGroup | std::vector<OrderId>| 被撤销的订单id列表 |


&emsp;&emsp;
<br/>

---

## 撤销策略实例所有挂单
c++
```c++
    std::vector<OrderId> cancelAllOrderOfStgInst(
        const StgInstInfoSPtr& stgInstInfo);
```
python
```python
    def cancel_all_order_of_stg_inst(stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | StgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| OrderIdGroup | std::vector<OrderId>| 被撤销的订单id列表 |


&emsp;&emsp;
<br/>

---

## 撤销一个算法单下所有订单
c++
```c++
    std::vector<OrderId> cancelAllOrderOfAlgo(AlgoId algoId);
```
python
```python
    def cancel_all_order_of_algo(algo_id)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| algoId | uint64 | 算法单编号 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| OrderIdGroup | std::vector<OrderId>| 被撤销的订单id列表 |


&emsp;&emsp;
<br/>

---
## 创建一个算法单
c++
```c++
  std::tuple<int, AlgoId> algoOrder(const StgInstInfoSPtr& stgInstInfo,
                                    const std::string& algoType,
                                    const std::string& algoName,
                                    std::uint32_t lifetime,
                                    const std::string& algoParamsInJsonFmt);
```
python
```python
    def algo_order(stg_inst_info, algo_type, algo_name, life_time, algo_params_in_json_fmt)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | StgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| algoType | string | 算法单类型，比如TWAP或者SmartOrder |
| algoName | string | 算法单名称 |
| lifeTime | uint32 | 算法单生命周期 |
| algoParamsInJsonFmt | string | JSON格式的算法单参数 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| algoId | uint64 | 系统分配的算法单编号 |  

&emsp;&emsp;
<br/>

---

## 撤销一个算法单
c++
```c++
   int cancelAlgoOrder(AlgoId algoId);
```
python
```python
    def cancel_algo_order(algo_id)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| algoId | uint64 | 算法单编号 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |


&emsp;&emsp;
<br/>

---

## 订阅
c++
```c++
    int sub(StgInstId subscriber, const std::string& topic);
```
python
```python
    def sub(stg_inst_id, topic);
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| subscriber | uint16 | 订阅的策略实例id |
| topic | string | 订阅的topic |

行情的 topic 格式为：shm://MD.市场.代码类型/代码/行情类型，比如：shm://MD.SSE.Spot/588180/Tickers，注意大小写敏感，市场、代码类型、行情类型参考 BQConstIF.hpp，订阅行情示例：
```python
    def on_stg_inst_start(self, stg_inst_info):
        if stg_inst_info.stg_inst_id == 1:
            # sub market data of trades, note that the topic is case sensitive.
            self.stg_eng.sub(
                stg_inst_info.stg_inst_id, "shm://MD.SZSE.Spot/000002/Trades"
            )   
```
上面是1号策略实例订阅SZSE市场000002代码的逐笔成交。  

除了行情，这个接口还可以订阅PNL以及子系统通过PubTopic接口发布的topic信息，订阅PNL示例：
```python
    if stg_inst_info.stg_inst_id == 1:
        # sub pos info of stg id 10000, note that the topic is case sensitive.
        self.stg_eng.sub(
            stg_inst_info.stg_inst_id,
            "shm://RISK.PubChannel.Trade/PosInfo/StgId/10000",
        )
 
        # sub pos info of stg inst id 1, note that the topic is case sensitive.
        self.stg_eng.sub(
            stg_inst_info.stg_inst_id,
            "shm://RISK.PubChannel.Trade/PosInfo/StgId/10000/StgInstId/1",
        )

        # sub pos info of acct id 10000, note that the topic is case sensitive.
        self.stg_eng.sub(
            stg_inst_info.stg_inst_id,
            "shm://RISK.PubChannel.Trade/PosInfo/AcctId/10000",
        )
 
```
上面是策略10000的1号策略实例发起订阅策略10000的盈亏、策略10000的1号策略实例以及资金账户10000的盈亏，订阅成功后在以下回调中触发：
* [账户层面仓位变动信息](策略引擎#账户层面仓位变动信息)
* [账户层面仓位快照信息](策略引擎#账户层面仓位快照信息)
* [策略层面仓位变动信息](策略引擎#策略层面仓位变动信息)
* [策略层面仓位快照信息](策略引擎#策略层面仓位快照信息)
* [策略实例层面仓位变动信息](策略引擎#策略实例层面仓位变动信息)
* [策略实例层面仓位快照信息](策略引擎#策略实例层面仓位快照信息)
  
```python
    if stg_inst_info.stg_inst_id == 1:
          self.stg_eng.sub(
              stg_inst_info.stg_inst_id,
              shm://RISK.PlugInChannel.Trade/TriggerRiskCrtl/StgId/10000
          )

          self.stg_eng.sub(
              stg_inst_info.stg_inst_id,
              shm://RISK.PlugInChannel.Trade/TriggerRiskCrtl/StgId/10000/StgInstId/1
          )

          self.stg_eng.sub(
              stg_inst_info.stg_inst_id,
              shm://RISK.PlugInChannel.Trade/TriggerRiskCrtl/AcctId/10000
          )
```
上面是1号策略实例订阅策略层面、策略实例层面、资金账户层面触发的风控预警，订阅成功后在回调 [TOPIC推送](策略引擎#TOPIC推送) 中触发，所有的这些订阅推送都通过共享内存交互。  

</br>  

返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |

&emsp;&emsp;
<br/>


---

## 取消订阅
c++
```c++
    int unSub(StgInstId subscriber, const std::string& topic);
```
python
```python
    def unsub(stg_inst_id, topic);
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| subscriber | uint16 | 取消的策略实例id |
| topic | string | 取消订阅的topic |

行情的topic格式为：shm://MD.市场.代码类型/代码/行情类型，比如：shm://MD.SSE.Spot/588180/Tickers，注意大小写敏感，市场、代码类型、行情类型参考 BQConstIF.hpp
</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |

&emsp;&emsp;
<br/>


---

## 给策略实例安装一个固定时间的定时器
给策略实例安装一个在某一固定时间点触发的定时器。在[定时器触发事件](策略引擎#策略实例定时器触发事件)中触发回调。  
c++
```c++
   void installStgInstTimer(StgInstId stgInstId, const std::string& timerName,
                            const std::string& execTime,
                            std::uint32_t timeZone = 8); 
```
python
```python
   def install_stg_inst_timer(stg_inst_id, timer_name, exec_time, time_zone)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstId  | uint16 | 策略实例id |
| timerName  | string | 定时器名称 |
| execTime  | string | 触发时间点 |
| timeZone  | uint32 | 时区 |

关于触发时间点的值，目前系统内部是这么处理的，根据最后一个timeZone（默认东八区），每隔一定的时间获取当前的时间点，例如2020年1月23日10点15分20秒的格式为Y2020M01D23h10m15s20的字符串形式，然后检查Y2020M01D23h10m15s20时候包含字符串execTime，如果包含就触发此定时器。下面是execTime的几个例子：

| execTime | 触发时间 |  
| ---- | ---- |
| s20  | 每分钟的第20秒触发一次 | 
| m15s20  | 每个小时的第15分20秒触发一次 | 
| h10m15s20  | 每天的10点15分20秒触发一次 | 
| D23h10 | 每个月23号10点触发一次 | 

实际上系统内部处理比上面描述的要复杂很多，所以不用担心有定时器错过触发时间点的问题。另外为了防止系统关闭后再次启动导致多次触发定时器的问题，当系统刚启动的时候时间点就满足条件的情况下是不会触发回调的，举个例子：execTime为h10的时候，每天10点触发定时器，假设刚启动的时候就是10点，这时候是不会触发定时器的。

&emsp;&emsp;
<br/>


---

## 给策略实例安装一个间隔执行的定时器
给策略实例安装一个每隔一段时间触发的定时器。在[定时器触发事件](策略引擎#策略实例定时器触发事件)中触发回调。    
c++
```c++
  void installStgInstTimer(StgInstId stgInstId, const std::string& timerName,
                            ExecAtStartup ExecAtStartup ,
                            std::uint32_t milliSecInterval,
                            std::uint64_t maxExecTimes = UINT64_MAX);
```
python
```python
   def install_stg_inst_timer(stg_inst_id, timer_name, exec_time, time_zone)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstId  | uint16 | 策略实例id |
| timerName  | string | 定时器名称 |
| ExecAtStartup | ExecAtStartup | 是否启动的时候马上触发一次 |
| milliSecInterval | uint32 | 触发间隔（单位：毫秒） |
| maxExecTimes | uint64 | 最大触发次数 |

注意间隔执行的定时器和定时执行的定时器不能同名，否则移除定时器的时候会把两者都移除，但是不同策略实例的间隔执行的定时器和不同策略实例的定时执行的定时器可以同名。  

&emsp;&emsp;
<br/>


---

## 移除一个定时器
从策略实例移除一个定时器。    
c++
```c++
  void uninstallStgInstTimer(StgInstId stgInstId, const std::string& timerName);
```
python
```python
   def uninstall_stg_inst_timer(stg_inst_id, timer_name)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstId  | uint16 | 策略实例id |
| timerName  | string | 定时器名称 |

&emsp;&emsp;
<br/>


---

## 获取订单信息
c++
```c++
    std::tuple<int, OrderInfoSPtr> getOrderInfo(OrderId orderId) const;
```
python
```python
    def get_order_info(order_id)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| orderId | uint64 | 内部订单id |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| orderInfo | OrderInfo | [订单的详细信息](策略引擎#订单信息) |
</br>  

&emsp;&emsp;
<br/>


---

## 获取策略实例所有未完结订单
c++

```c++
   std::vector<OrderInfoSPtr> getUnclosedOrderInfoGroup(
       const StgInstInfoSPtr& stgInstInfo) const;
```
python
```python
    def get_unclosed_order_info_group(stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |


&emsp;&emsp;
<br/>

---

## 获取策略实例仓位信息
c++

```c++
   PosOfStgInstGroupSPtr getPosOfStgInst(
       const StgInstInfoSPtr& stgInstInfo) const;
```
python
```python
    def get_pos_of_stg_inst(stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| posOfStgInstGroup | posOfStgInstGroup | 策略实例仓位列表 |

策略实例仓位列表是一个包含posOfStgInst的数组，参考[策略实例仓位信息](策略引擎#策略实例仓位信息)

&emsp;&emsp;
<br/>


---

## 查询两个时间点之间历史行情
c++
```c++
   std::tuple<int, std::string> queryHisMDBetween2Ts(
       MarketCode marketCode, SymbolType symbolType,
       const std::string& symbolCode, MDType mdType, std::uint64_t tsBegin,
       std::uint64_t tsEnd, const std::string& ext = "");
```
python
```python
    def query_his_md_between_2_ts(market_code, symbol_type, symbol_code, md_type, ts_begin, ts_end, ext)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| mdType | MDType | 行情类型 |
| tsBegin | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| tsEnd | uint64 | 查询历史行情的结束时间点，单位微秒，utc时间 |
| ext | string |  |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |

&emsp;&emsp;
<br/>


---

## 查询某时间点之前的历史行情
c++
```c++
   std::tuple<int, std::string> querySpecificNumOfHisMDBeforeTs(                               
       MarketCode marketCode, SymbolType symbolType,                                           
       const std::string& symbolCode, MDType mdType, std::uint64_t ts, int num,                
       const std::string& ext = "");        
```
python
```python
    def query_specific_num_of_his_md_before_ts(market_code, symbol_type, symbol_code, md_type, ts, num, ext)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| mdType | MDType | 行情类型 |
| ts | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| num | int | 需要获取的历史行情记录数 |
| ext | string |  |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |


&emsp;&emsp;
<br/>


---

## 查询某时间点之后的历史行情
c++
```c++
   std::tuple<int, std::string> querySpecificNumOfHisMDAfterTs(                                
       MarketCode marketCode, SymbolType symbolType,                                           
       const std::string& symbolCode, MDType mdType, std::uint64_t ts, int num,                
       const std::string& ext = "");      
```
python
```python
    def query_specific_num_of_his_md_after_ts(market_code, symbol_type, symbol_code, md_type, ts, num, ext)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| mdType | MDType | 行情类型 |
| ts | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| num | int | 需要获取的历史行情记录数 |
| ext | string |  |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |


&emsp;&emsp;
<br/>



---

## 根据topic查询两个时间点之间历史行情
c++
```c++
   std::tuple<int, std::string> queryHisMDBetween2Ts(
       const std::string& topic, std::uint64_t tsBegin, std::uint64_t tsEnd);
```
python
```python
    def query_his_md_between_2_ts(topic, ts_begin, ts_end)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| topic | string | 需要查询的历史行情的topic |
| tsBegin | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| tsEnd | uint64 | 查询历史行情的结束时间点，单位微秒，utc时间 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |

&emsp;&emsp;
<br/>


---

## 根据topic查询某时间点之前的历史行情
c++
```c++
   std::tuple<int, std::string> querySpecificNumOfHisMDBeforeTs(                               
       const std::string& topic, std::uint64_t ts, int num);        
```
python
```python
    def query_specific_num_of_his_md_before_ts(topic, ts, num)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| topic | string | 需要查询的历史行情的topic |
| ts | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| num | int | 需要获取的历史行情记录数 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |


&emsp;&emsp;
<br/>


---

## 根据topic查询某时间点之后的历史行情
c++
```c++
   std::tuple<int, std::string> querySpecificNumOfHisMDAfterTs(                                
       const std::string& topic, std::uint64_t ts, int num);      
```
python
```python
    def query_specific_num_of_his_md_after_ts(topic, ts, num)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| topic | string | 需要查询的历史行情的topic |
| ts | uint64 | 查询历史行情的起始时间点，单位微秒，utc时间 |
| num | int | 需要获取的历史行情记录数 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| statusCode | int | 状态码，0：成功；其他：失败，可通过GetStatusMsg获取错误信息 |
| hisMD | string | json格式的历史行情 |

&emsp;&emsp;
<br/>


---

## 保存策略实例数据
由于策略在运行期间可能会有一些状态要保存，可以通过这个函数将这些数据保存到硬盘，为了不影响性能，这些数据可保存在linux的tmpfs系统中，tmpfs的目录可以在策略的配置文件中通过rootDirOfStgPrivateData项指定，保存的数据建议用json格式。
c++

```c++
   bool saveStgPrivateData(StgInstId stgInstId, const std::string& jsonStr);                   
```
python
```python
    def save_stg_private_data(stg_inst_id, json_str)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstId | string | 策略实例id |
| jsonStr | string | 需要保存的数据 |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| ret | bool | 成功或失败 |

&emsp;&emsp;
<br/>


---

## 加载策略实例数据
c++

```c++
   std::string loadStgPrivateData(StgInstId stgInstId);
```
python
```python
    def load_stg_private_data(stg_inst_id)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstId | string | 策略实例id |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| StgPrivateData | string | 策略实例数据 |

&emsp;&emsp;
<br/>


---

## 策略运行信息输出
c++

```c++
   void logDebug(const std::string& fmt, const std::vector<std::string>& args,
                 const StgInstInfoSPtr& stgInstInfo = nullptr,
                 NotifyToTerminal notifyToTerminal = NotifyToTerminal::False);
 
   void logInfo(const std::string& fmt, const std::vector<std::string>& args,
                const StgInstInfoSPtr& stgInstInfo = nullptr,
                NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logWarn(const std::string& fmt, const std::vector<std::string>& args,
                const StgInstInfoSPtr& stgInstInfo = nullptr,
                NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logError(const std::string& fmt, const std::vector<std::string>& args,
                 const StgInstInfoSPtr& stgInstInfo = nullptr,
                 NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logCritical(const std::string& fmt, const std::vector<std::string>& args,
                    const StgInstInfoSPtr& stgInstInfo = nullptr,
                    NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logTrace(const std::string& fmt,
                 const StgInstInfoSPtr& stgInstInfo = nullptr,
                 NotifyToTerminal notifyToTerminal = NotifyToTerminal::False);
 
   void logDebug(const std::string& fmt,
                 const StgInstInfoSPtr& stgInstInfo = nullptr,
                 NotifyToTerminal notifyToTerminal = NotifyToTerminal::False);
 
   void logInfo(const std::string& fmt,
                const StgInstInfoSPtr& stgInstInfo = nullptr,
                NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logWarn(const std::string& fmt,
                const StgInstInfoSPtr& stgInstInfo = nullptr,
                NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logError(const std::string& fmt,
                 const StgInstInfoSPtr& stgInstInfo = nullptr,
                 NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
 
   void logCritical(const std::string& fmt,
                    const StgInstInfoSPtr& stgInstInfo = nullptr,
                    NotifyToTerminal notifyToTerminal = NotifyToTerminal::True);
```
python
```python
    def log_trace(fmt, args, stg_inst_info, NotifyToTerminal)
    def log_debug(fmt, args, stg_inst_info, NotifyToTerminal)
    def log_info(fmt, args, stg_inst_info, NotifyToTerminal)
    def log_warn(fmt, args, stg_inst_info, NotifyToTerminal)
    def log_error(fmt, args, stg_inst_info, NotifyToTerminal)
    def log_critical(fmt, args, stg_inst_info, NotifyToTerminal)

    def log_trace(fmt, stg_inst_info, NotifyToTerminal)
    def log_debug(fmt, stg_inst_info, NotifyToTerminal)
    def log_info(fmt, stg_inst_info, NotifyToTerminal)
    def log_warn(fmt, stg_inst_info, NotifyToTerminal)
    def log_error(fmt, stg_inst_info, NotifyToTerminal)
    def log_critical(fmt, stg_inst_info, NotifyToTerminal)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| fmt | string | 日志格式 |
| args | std::vector<std::string> | 日志参数 |
| stgInstInfo | stgInstInfo | 输出日志的[策略实例信息](策略引擎#策略实例信息) |
| NotifyToTerminal | enum | 如果是IsTrue，那么改信息会被输出到[前端](前端#系统维护) |

</br>  
返回：无  

&emsp;&emsp;
<br/>


---
## 保存PNL
这个功能其实可有可无，因为目前的设计中仓位变动流水都保存了下来，结合历史行情可以计算出任意时间点各个层面的浮动盈亏。  
c++

```c++
   void saveToDB(const PnlSPtr& pnl);
```
python
```python
    def save_to_db(pnl)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| pnl | Pnl | pnl信息 |

</br>  

&emsp;&emsp;
<br/>


---

## 获取策略实例仓位信息
c++

```c++
   PosOfStgInstGroupSPtr getPosOfStgInst(
       const StgInstInfoSPtr& stgInstInfo) const;
```
python
```python
    def get_pos_of_stg_inst(stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  
返回：  

| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| posOfStgInstGroup | posOfStgInstGroup | 策略实例仓位列表 |

策略实例仓位列表是一个包含posOfStgInst的数组，
PosOfStgInst:
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | StgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| acctId | uint16 | 内部账户 |
| algoId| uint32 | 算法单id |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| side | Side | 买卖 |
| posSide | PosSide | 多空 |
| parValue | ParValue | 面值/合约乘数 |
| feeCurrency | FeeCurrency | 手续费币种 |
| fee | double | 手续费 |
| pos | double | 仓位 |
| avgOpenPrice | double | 开仓均价 |
| posUnreal | double | 在途仓位，即挂单中尚未买入或者卖出成功的仓位 |
| avgOrderPrice | double | 挂单均价 |

</br>   
  
# 策略引擎回调

## 获取策略引擎对象
c++

```c++
   StgEng* getStgEng() const;
```
python
```python
    def stg_eng()
```

&emsp;&emsp;
<br/>


---

## 人工干预指令处理
用户可通过系统内置的WEB服务发起人工干预指令即可触发此回调。  
c++

```c++
   virtual void onStgManualIntervention(const StgInstInfoSPtr& stgInstInfo,
                                        const CommonIPCDataSPtr& commonIPCData) {
   }
```
python
```python
    def on_stg_manual_intervention(self, stg_inst_info, stg_manual_intervention):
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| commonIPCData | CommonIPCData | 人工干预指令信息，python中为一个json格式的字符串 |

</br>  

&emsp;&emsp;
<br/>


---

## TOPIC推送
用户订阅了TOPIC之后，如果有相应的topic推送，即可触发此回调。  
c++
```c++
   virtual void onPushTopic(const StgInstInfoSPtr& stgInstInfo,                                
                            const TopicContentSPtr& topicContent) {}  
```
python
```python
    def on_push_topic(self, stg_inst_info, topic_content)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| topicContent | TopicContent | topic内容，python中为一个json格式的字符串 |

</br>  

&emsp;&emsp;
<br/>


---

## 委托回报
订单状态或者成交数量有变化就马上能收到回报。  
c++
```c++
   virtual void onOrderRet(const StgInstInfoSPtr& stgInstInfo,                                 
                           const OrderInfoSPtr& orderInfo) {}    
```
python
```python
    def on_order_ret(self, stg_inst_info, order_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| OrderInfo | orderInfo | 订单的详细信息 |

</br>  

&emsp;&emsp;
<br/>


---

## 撤单应答
撤单结果处理。  
c++
```c++
   virtual void onCancelOrderRet(const StgInstInfoSPtr& stgInstInfo,                           
                                 const OrderInfoSPtr& orderInfo) {} 
```
python
```python
    def on_order_ret(self, stg_inst_info, order_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| OrderInfo | orderInfo | 订单的详细信息 |

通过orderInfo中的statusCode可以知道撤单的结果是成功还是失败。

</br>  


&emsp;&emsp;
<br/>


---

## 逐笔成交
c++
```c++
   virtual void onTrades(const StgInstInfoSPtr& stgInstInfo,
                         const TradesSPtr& trades) {} 
```
python
```python
    def on_trades(self, stg_inst_info, trades)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| trades | Trades | 逐笔成交 |

</br>  


&emsp;&emsp;
<br/>


---

## 逐笔委托
c++
```c++
   virtual void onOrders(const StgInstInfoSPtr& stgInstInfo,
                         const OrdersSPtr& orders) {} 
```
python
```python
    def on_orders(self, stg_inst_info, orders)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| orders | Orders | 逐笔委托 |

</br>  

&emsp;&emsp;
<br/>


---

## 订单簿
c++
```c++
   virtual void onBooks(const StgInstInfoSPtr& stgInstInfo,
                        const BooksSPtr& books) {} 
```
python
```python
    def on_books(self, stg_inst_info, books)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| books | Books | 订单簿 |

</br>  

&emsp;&emsp;
<br/>


---

## Candle
c++
```c++
   virtual void onCandle(const StgInstInfoSPtr& stgInstInfo,
                         const CandleSPtr& candle) {} 
```
python
```python
    def on_candle(self, stg_inst_info, candle)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| candle | Candle | K线 |

</br>  

&emsp;&emsp;
<br/>


---

## Tickers
c++
```c++
   virtual void onTickers(const StgInstInfoSPtr& stgInstInfo,
                          const TickersSPtr& tickers) {} 
```
python
```python
    def on_tickers(self, stg_inst_info, tickers)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| tickers | Tickers | tickers |

</br>  

&emsp;&emsp;
<br/>



---

## 策略启动事件
c++
```c++
    virtual void onStgStart() {}
```
python
```python
    def on_stg_start(self)
```
  
</br>  

&emsp;&emsp;
<br/>


---

## 策略实例启动事件
c++
```c++
    virtual void onStgInstStart(const StgInstInfoSPtr& stgInstInfo) {}
```
python
```python
    def on_stg_inst_start(self, stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  


&emsp;&emsp;
<br/>


---

## 新增策略实例事件
c++
```c++
    virtual void onStgInstAdd(const StgInstInfoSPtr& stgInstInfo) {}
```
python
```python
    def on_stg_inst_add(self, stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  


&emsp;&emsp;
<br/>


---

## 移除策略实例事件
c++
```c++
    virtual void onStgInstDel(const StgInstInfoSPtr& stgInstInfo) {}
```
python
```python
    def on_stg_inst_del(self, stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  

&emsp;&emsp;
<br/>


---

## 策略实例参数变化事件
c++
```c++
    virtual void onStgInstChg(const StgInstInfoSPtr& stgInstInfo) {}
```
python
```python
    def on_stg_inst_chg(self, stg_inst_info)
```
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |

</br>  

&emsp;&emsp;
<br/>


---

## 策略实例定时器触发事件
安装了 [定时器](策略引擎#给策略实例安装一个固定时间的定时器) 之后，会触发此回调。  
c++
```c++
   virtual void onStgInstTimer(const StgInstInfoSPtr& stgInstInfo,
                               const std::string& timerName) {}
```
python
```python
    def on_stg_inst_timer(self, stg_inst_info, timerName)
```
  
</br>  


&emsp;&emsp;
<br/>


---

## 账户层面仓位变动信息
c++
```c++
   virtual void onPosUpdateOfAcctId(const StgInstInfoSPtr& stgInstInfo,
                                    const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_update_of_acct_id(self, stg_inst_info, pos_snapshot)
```
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |

posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  


&emsp;&emsp;
<br/>


---

## 账户层面仓位快照信息
c++
```c++
   virtual void onPosSnapshotOfAcctId(const StgInstInfoSPtr& stgInstInfo,
                                      const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_snapshot_of_acct_id(self, stg_inst_info, pos_snapshot)
```
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |
 
posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  


&emsp;&emsp;
<br/>


---

## 策略层面仓位变动信息
c++
```c++
   virtual void onPosUpdateOfStgId(const StgInstInfoSPtr& stgInstInfo,
                                   const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_update_of_stg_id(self, stg_inst_info, pos_snapshot)
```
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |
 
posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  


&emsp;&emsp;
<br/>


---

## 策略层面仓位快照信息
c++
```c++
   virtual void onPosSnapshotOfStgId(const StgInstInfoSPtr& stgInstInfo,
                                      const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_snapshot_of_stg_id(self, stg_inst_info, pos_snapshot)
```
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |
 
posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  


&emsp;&emsp;
<br/>



---

## 策略实例层面仓位变动信息
c++
```c++
   virtual void onPosUpdateOfStgInstId(const StgInstInfoSPtr& stgInstInfo,
                                       const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_update_of_stg_inst_id(self, stg_inst_info, pos_snapshot)
```
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |
 
posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  


&emsp;&emsp;
<br/>


---

## 策略实例层面仓位快照信息
c++
```c++
   virtual void onPosSnapshotOfStgInstId(const StgInstInfoSPtr& stgInstInfo,
                                         const PosSnapshotSPtr& posSnapshot) {}
```
python
```python
    def on_pos_snapshot_of_stg_inst_id(self, stg_inst_info, pos_snapshot)
```
   
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | stgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| posSnapshot | PosSnapshot | 仓位全量快照 |
  
posSnapshot可以通过各种维度组合获取各个层面的盈亏信息，详情参考 [盈亏监控](策略引擎#盈亏监控)，同样可以通过各个维度获取各个层面的仓位信息，详情参考 [仓位快照](策略引擎#仓位快照) 
  
</br>  

&emsp;&emsp;
<br/>


---

# 盈亏监控
## 盈亏的维度
&emsp;&emsp;PNL有多个维度，或者多个维度的组合，比如产品层面、策略组合层面、资金账号层面、策略或者策略实例层面，或者策略加上资金账号层面，以下是目前系统中可用的PNL维度，通过这些维度，你可以获取某个维度的已实现和未实现盈亏，或者多个维度自由组合的已实现和未实现盈亏。  

| 维度字段 | 维度名称 | 维度说明 |
| ---- | ---- | ---- |
| productGrpId | 产品组合 |  |
| productId | 产品 |  |
| userId | 用户 |  |
| acctGrpId | 账号组合 | |
| acctId | 账号 | |
| trdAcctId | 交易账号 | |
| stgGrpId | 策略组合 |  |
| stgId | 策略 | |
| stgInstId | 策略实例 | |
| algoId | 算法单 | |
| marketCode | 市场 | |
| symbolType | 代码类型 | |
| symbolCode | 代码 | |
| side | 买卖 | |
| posSide | 多空 | |
| parValue | 面值/合约乘数 | |
| feeCurrency | 手续费币种 | 为接入更多的市场预留 |

订阅了仓位变动或者仓位快照之后，通过仓位变动或者快照的回调函数中的posSnapshot你可以实时获取各个维度的盈亏信息。

&emsp;&emsp;
<br/>


## 盈亏的监控
&emsp;&emsp;通过下面的代码，你可以获取账户10000在策略9000的1号策略实例的已实现盈亏和未实现盈亏。上面的所有维度你都可以通过维度名称等于某个值再用&叠加起来，从而得到你想要的任意组合的PNL信息。目前我们收到的PNL的最大粒度为策略层面、策略实例层面、账号层面，如果需要监控策略组合的盈亏，那么你可以创建一个监控策略，订阅这个策略组合下的所有策略，盈亏到达一定的程度可以向组合中的策略发起人工干预指令。  

```python
    def on_pos_update_of_stg_id(self, stg_inst_info, pos_snapshot):
        # query pnl of acctId=10000&stgId=9000&stgInstId=1
        if stg_inst_info.stg_inst_id == 1:
            ret_of_query_pnl = pos_snapshot.query_pnl(
                query_cond="acctId=10000&stgId=9000&stgInstId=1",
                quote_currency_for_calc="CNY",
                quote_currency_for_conv="CNY",
            )   
            status_code = ret_of_query_pnl[0]
            if status_code == 0:
                pnl = ret_of_query_pnl[1]
                print(f"pnl update = {pnl.to_str()}")
            else:
                status_msg = get_status_msg(status_code)
                print(f"{status_code} - {status_msg}")
        return
```
下面是一些维度组合（上面代码中的query_cond）的例子，表格中的盈亏包括已实现盈亏和未实现盈亏：  

| query_cond | 说明 |
| ---- | ---- |
| stgId=10000 | 10000号策略的盈亏 |
| stgInstId=1 | 1号策略实例的盈亏 |
| stgInstId=1&algoId=10000 | 1号策略实例10000号算法单的盈亏 |
| marketCode=SZSE&symbolCode=000002 | 交易SZSE市场000002代码产生盈亏 |
| stgInstId=1&marketCode=SZSE&symbolCode=000002&side=Bid | 1号策略实例买入SZSE市场000002代码产生盈亏 |
| stgInstId=1&marketCode=CZCE&symbolCode=SR2309&side=Bid | 1号策略实例做多CZCE市场SR2309产生的盈亏 |

</br>  

&emsp;&emsp;
<br/>

---

# 仓位快照
## 仓位快照的维度
&emsp;&emsp;和PNL一样，仓位快照有多个维度，或者多个维度的组合，比如产品层面、策略组合层面、资金账号层面、策略或者策略实例层面，或者策略加上资金账号层面，以下是目前系统中可用的PNL维度，通过这些维度，你可以获取某个维度的仓位信息，或者多个维度自由组合的仓位信息。  

| 维度字段 | 维度名称 | 维度说明 |
| ---- | ---- | ---- |
| productGrpId | 产品组合 |  |
| productId | 产品 |  |
| userId | 用户 |  |
| acctGrpId | 账号组合 | |
| acctId | 账号 | |
| trdAcctId | 交易账号 | |
| stgGrpId | 策略组合 |  |
| stgId | 策略 | |
| stgInstId | 策略实例 | |
| algoId | 算法单 | |
| marketCode | 市场 | |
| symbolType | 代码类型 | |
| symbolCode | 代码 | |
| side | 买卖 | |
| posSide | 多空 | |
| parValue | 面值/合约乘数 | |
| feeCurrency | 手续费币种 | 为接入更多的市场预留 |

订阅了仓位变动或者仓位快照之后，通过仓位变动或者快照的回调函数中的posSnapshot你可以实时获取各个维度的仓位信息。

&emsp;&emsp;
<br/>


## 仓位的获取
&emsp;&emsp;通过下面的代码，你可以获取各个层面的仓位信息。  

```python
    # 获取stgId=10000&stgInstId=1的仓位快照
    ret_of_query = pos_snapshot.query_pos_info_group("stgId=10000&stgInstId=1")
    status_code = ret_of_query[0]
    if status_code != 0:
      return
    pos_info_group = ret_of_query[1]
    for i in range(len(pos_info_group)):
        print(f"{pos_info_group[i].to_str()}")
 
    # 按照stgId&stgInstId分组的仓位快照
    ret_of_query = pos_snapshot.query_pos_info_group_by("stgId&stgInstId")
    status_code = ret_of_query[0]
    if status_code != 0:
      return
    key_to_pos_info_bundle = ret_of_query[1]
    for rec in key_to_pos_info_bundle:
        print(rec.key())
        pos_info_bundle = rec.data()
        for i in range(len(pos_info_bundle)):
            print(f"pos info bundle {pos_info_bundle[i].to_str()}")
 
```

</br>  

&emsp;&emsp;
<br/>

---
  
# 几个重要的数据结构
## 订单信息
当策略引擎发起下单指令之后，系统内就会生成一张订单，然后这张订单就会在系统内流转，直到其完结。  
</br>  
OrderInfo:
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| productId | uint16 | 产品id |
| userId | uint16 | 用户id |
| algoId| uint32 | 算法单id |
| acctId | uint16 | 内部账号 |
| stgGrpId | uint16 | 策略组合id |
| stgId | uint16 | 策略id |
| stgInstId | uint16 | 策略实例id |
| algoId | uint32 | 算法单id |
| orderId | uint64 | 内部订单id |
| exchOrderId | string | 交易所订单id |
| parentOrderId | uint64 | 父订单id，系统内单边持仓用到，目前在暂不支持此功能 |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| exchSymbolCode | string | 交易所代码 |
| side | Side | 买卖 |
| posDirection | PosDirection | 开平 |
| posSide | PosSide | 多空 |
| orderPrice | double | 下单价格 |
| orderSize | double | 下单数量 |
| parValue | ParValue | 面值/合约乘数 |
| orderType | OrderType | 下单类型，比如：限价单 |
| orderTypeExtra | OrderTypeExtra | 高级限价单类型，目前暂时不支持此功能 |
| orderStg | OrderStg | 下单策略，比如是否允许平今 |
| orderTime | uint64 | 下单时间 |
| fee | double | 手续费 |
| feeCurrency | FeeCurrency | 手续费币种，考虑到系统将来可能会接入各种衍生品市场 |
| dealSize | double | 成交数量 |
| avgDealPrice | double | 成交均价 |
| lastTradeId | string | 最后一笔成交单号 |
| lastDealPrice | double | 最后一笔成交价格 |
| lastDealSize | double | 最后一笔成交数量 |
| lastDealTime | uint64 | 最后一笔成交时间 |
| orderStatus | OrderStatus | 订单状态 |
| statusCode | int | 订单状态码，如果失败状态码不为0 |
  
</br>  

&emsp;&emsp;
<br/>


---

## 策略实例信息
策略实例信息包含了所有策略实例相关信息，策略引擎的每一个回调事件基本都会带出此参数，方便用户使用。  
</br>  
StgInstInfo:
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| productId | uint16 | 产品id |
| stgGrpId | uint16 | 策略组合id |
| stgId | uint16 | 策略id |
| stgName | string | 策略名称 |
| userIdOfAuthor | string | 策略作者 |
| stgInstId | uint16 | 策略实例编号 |
| stgInstParams | string | 策略实例参数，数据库中配置，建议用json格式 |
| stgInstName | string | 策略实例名称 |
| userId | string | 用户id，对于手拍单策略，每个策略实例对应一个用户 |
| isDel | int | 是否启用 |

</br>  

&emsp;&emsp;
<br/>


---

## 策略实例仓位信息
&emsp;&emsp;策略实例仓位信息由PosOfStgInst数组组成，考虑到一些市场可以做空现货，查询现货仓位可能会返回两条记录，即多头头寸和空头头寸，但是国内二级市场理论上只有多头头寸那条记录有仓位（pos字段）信息，而空头头寸那条记录只有在途仓位（posUnreal字段）信息，也就是挂单卖出尚未成功的仓位信息。  
</br>  
PosOfStgInst:
  
| 参数名称 | 参数类型 | 参数说明 |
| ---- | ---- | ---- |
| stgInstInfo | StgInstInfo | [策略实例信息](策略引擎#策略实例信息) |
| acctId | uint16 | 内部账户 |
| algoId| uint32 | 算法单id |
| marketCode | MarketCode | 市场 |
| symbolType | SymbolType | 代码类型 |
| symbolCode | string | 代码 |
| side | Side | 买卖 |
| posSide | PosSide | 开平 |
| parValue | ParValue | 面值/合约乘数 |
| feeCurrency | FeeCurrency | 手续费币种 |
| fee | double | 手续费 |
| pos | double | 仓位 |
| avgOpenPrice | double | 开仓均价 |
| posUnreal | double | 在途仓位，即挂单中尚未买入或者卖出成功的仓位 |
| avgOrderPrice | double | 挂单均价 |

</br>  

&emsp;&emsp;
<br/>


---
# 系统策略

## 手拍单
&emsp;&emsp;手拍单策略主要是用于处理全端页面发起的手工报撤单请求，前端界面发起的手工报撤单请求先会被发到web服务，web服务再将其转发至手拍单策略，后面的逻辑就和交易策略发起的报撤单没什么区别了，手拍单策略的策略编号为1，手拍单策略为系统内置的交易策略，系统内置的交易策略的策略编号的区间是[1, 10000)
